02-08-2023

INFRASTRUCTURE:
resources used to run our application on cloud.
ex: ec2, s3, elb, vpc --------------

in genral we used to deploy infra on manual 

Manual:
1. time consume
2. manual work
3. commiting mistakes

Automate -- > Terraform -- > code -- > hcl (Hashicorp configuration languge)


its a tool used to make infrastructure automation.
its a free and opensource.
its platform independent.   - u can install it on any OS
it comes on year 2014.
who developed : mitchel hasimoto 
own by: hasicorp 
terraform is written on go language.
We can call terraform as IAAC TOOL.  

HOW IT WORKS:
terraform uses code to automate the infra.
we use HCL : HashiCorp Configuration Language.

IAAC: Infrastructure as a code.

Code --- > execute --- > Infra 

ADVANTGAES:
1. Reuseable  - u can resue the terraform file
2. Time saving
3. Automation  - without manual work the code is repeatdly working  
4. Avoiding mistakes
5. Dry run  - without executing the code we can see output

------------
** Each cloud platform having their automate infra builder **
1. AWS = CFT ( Cloud Formamtion Template )
2. AZURE = ARM ( Azure Resource Management )
3. GOOGLE = GDE ( Google Deploy Engine )  

---------------------------------
iam user - adminaccess - create access key and secret key (security crendiatls - create acess key - CLI - next - dowload file) - in ec2 = aws configure - give acess and secret key - give region=us-east-1 - output=table


INSTALLING TERRAFORM:

sudo yum install -y yum-utils shadow-utils
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo
sudo yum -y install terraform
aws configure


mkdir terraform
cd terraform
---------------------------------

TERRAFORM COMMANDS:
terraform init	: initalize the provider plugins on backend
terraform plan	: to create execution plan for our resource (it reads the value from configuration file and it isoing to show whcih value is applicable for which resource ) 
terrafrom apply : to create resources
terrafrom destroy : to delete resources

CODE:
vim main.tf 

provider "aws" {                      # provider means whcih cloud actually
region = "us-east-1"
}

resource "aws_instance" "one" {
ami = "ami-0bb4c991fa89d4b9b"
instance_type = "t2.micro"
}

terraform init
terraform plan
terraform apply
terraform destroy 

STATE FILE: used to store the resource information which is created by terraform 
to track the resource activities
in real time entire resource info is on state file.
we need to keep it safe
if we lost this file we cant track the infra.
Command:
terraform state list

terrafrom target: used to destroy the specific resource 
terraform state list
single target: terraform destroy -target="aws_instance.one[3]"
multi targets: terraform destroy -target="aws_instance.one[3]" -target="aws_instance.one[2]"

---------------------------------------------------------------------------------------------------------------------------------------------
VARIABLES: to pass values as variables

vim main.tf

provider "aws" {
}

resource "aws_instance" "one" {
count = var.instance_count
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}  

------
vim variable.tf

variable "instance_type" {
description = "*"
type = string
default = "t2.micro"
}

variable "instance_count" {
description = "*"
type = number
default = 5
}

terraform apply --auto-approve
terraform destroy --auto-approve

------------------------------
How to change Secret key and access key in terraform

got to root path (cd) -> ls -al -> .aws (all AWS credential configuration will be here ) -> ll .aws/  -> vim .aws/credentials

------------------------------
Whenever u get error on terraform plan then first check on whcih file that error is and after that u need to check which block
--> Beacuse we have multiple resource block 

------------------------------
cat main.tf
provider "aws" {
}

resource "aws_instance" "one" {
count = var.instance_count
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}
------------
cat variables.tf
variable "instance_type" {
}

variable "instance_count" {
}
------------
cat raham.tfvars
instance_type = "t2.medium"
instance_count = 3
------------
cat dev.tfvars
instance_type = "t2.medium"
instance_count = 3
------------
cat test.tfvars
instance_type = "t2.micro"
instance_count = 5

FOR DEV ENV: terraform apply --auto-approve -var-file="dev.tfvars"
FOR TEST ENV: terraform apply --auto-approve -var-file="test.tfvars"

------------------------------
TERRAFORMCLI: used to pass values from cli

provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}

variable "instance_type" {
}

terraform apply --auto-approve -var="instance_type=t2.medium"
terraform destroy --auto-approve -var="instance_type=t2.medium"
------------------------------
provider "aws" {
}

resource "aws_instance" "one" {
ami = var.ami_id
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}

variable "instance_type" {
}

variable "ami_id" {
}

terraform apply --auto-approve -var="instance_type=t2.large" -var="ami_id=ami-0fa7190e664488b99"
terraform destroy --auto-approve -var="instance_type=t2.large" -var="ami_id=ami-0fa7190e664488b99"

------------------------------
TERRAFORM OUTPUTS: used to print the resource properties.
ex: public-ip, dns, instance type


provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-0fa7190e664488b99"
instance_type = "t2.micro"
tags = {
Name = "terra-server"
}
}

output "raham" {
value = [aws_instance.one.public_ip, aws_instance.one.private_ip, aws_instance.one.public_dns]
}

terraform apply --auto-approve
terraform destroy --auto-approve

---------------------------------------------------------------------------------------------------------------------------------------------
## AWS Terraform Instnaces

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

terraform apply --auto-approve
------------------------------
vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

terraform apply --auto-approve

------------------------------
## Terraform taint

Terraform taint = used to recreate specific objects 
in real time some resource we need to recreate if it will not work properly
then we can use taint concpet.
- here no need to execute the entire file.
- we can just mark the object as tainted.

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
}

terraform apply --auto-approve
terraform state list

for example , in  above tf file the aws_instance resource block with label name is not working i want to recreate , so in that case terraform taint is used.
-->
terraform taint aws_instance.four
terraform apply --auto-approve
--> so it will recreate the object(i.e resource aws_instance block)

------------------------------
## Terraform LifeCycle

Prevent_destroy : used to keep secure our resources without destrying

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
lifecycle {
prevent_destroy = true    # means it is not going to destroy 
}
}

terraform apply --auto-approve
terraform state list

------------------------------
vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
lifecycle {
prevent_destroy = false
}
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
lifecycle {
prevent_destroy = false
}
}

resource "aws_iam_user" "three"{
name = "karank"
lifecycle {
prevent_destroy = false
}
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
lifecycle {
prevent_destroy = true    # means it is not going to destroy 
}
}

terraform apply --auto-approve
terraform state list
->> means all resource are not getiing to destroy if i give prevent_destroy = false for particular block
