02-08-2023

Whenever you download service we need to always downlad repository.

INFRASTRUCTURE:
resources used to run our application on cloud.
ex: ec2, s3, elb, vpc --------------

in genral we used to deploy infra on manual 

Manual:
1. time consume
2. manual work
3. commiting mistakes

Automate -- > Terraform -- > code -- > hcl (Hashicorp configuration languge)


its a tool used to make infrastructure automation.
its a free and opensource.
its platform independent.   - u can install it on any OS
it comes on year 2014.
who developed : mitchel hasimoto 
own by: hasicorp 
terraform is written on go language.
We can call terraform as IAAC TOOL.  

HOW IT WORKS:
terraform uses code to automate the infra.
we use HCL : HashiCorp Configuration Language.

IAAC: Infrastructure as a code.

Code --- > execute --- > Infra 

ADVANTGAES:
1. Reuseable  - u can resue the terraform file
2. Time saving
3. Automation  - without manual work the code is repeatdly working  
4. Avoiding mistakes
5. Dry run  - without executing the code we can see output

------------
** Each cloud platform having their automate infra builder **
1. AWS = CFT ( Cloud Formamtion Template )
2. AZURE = ARM ( Azure Resource Management )
3. GOOGLE = GDE ( Google Deploy Engine )  

---------------------------------
iam user - adminaccess - create access key and secret key (security crendiatls - create acess key - CLI - next - dowload file) - in ec2 = aws configure - give acess and secret key - give region=us-east-1 - output=table


INSTALLING TERRAFORM:

sudo yum install -y yum-utils shadow-utils
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo
sudo yum -y install terraform
aws configure


mkdir terraform
cd terraform
---------------------------------

TERRAFORM COMMANDS:
terraform init	: initalize the provider plugins on backend
terraform plan	: to create execution plan for our resource (it reads the value from configuration file and it isoing to show whcih value is applicable for which resource ) 
terrafrom apply : to create resources
terrafrom destroy : to delete resources

CODE:
vim main.tf 

provider "aws" {                      # provider means whcih cloud actually
region = "us-east-1"
}

resource "aws_instance" "one" {
ami = "ami-0bb4c991fa89d4b9b"
instance_type = "t2.micro"
}

terraform init
terraform plan
terraform apply
terraform destroy 

STATE FILE: used to store the resource information which is created by terraform 
to track the resource activities
in real time entire resource info is on state file.
we need to keep it safe
if we lost this file we cant track the infra.
Command:
terraform state list

terrafrom target: used to destroy the specific resource 
terraform state list
single target: terraform destroy -target="aws_instance.one[3]"
multi targets: terraform destroy -target="aws_instance.one[3]" -target="aws_instance.one[2]"

---------------------------------------------------------------------------------------------------------------------------------------------
Lec - 46
---------------------------------------------------------------------------------------------------------------------------------------------
VARIABLES: to pass values as variables

vim main.tf

provider "aws" {
}

resource "aws_instance" "one" {
count = var.instance_count
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}  

------
vim variable.tf

variable "instance_type" {
description = "*"
type = string
default = "t2.micro"
}

variable "instance_count" {
description = "*"
type = number
default = 5
}

terraform apply --auto-approve
terraform destroy --auto-approve

------------------------------
How to change Secret key and access key in terraform

got to root path (cd) -> ls -al -> .aws (all AWS credential configuration will be here ) -> ll .aws/  -> vim .aws/credentials

------------------------------
Whenever u get error on terraform plan then first check on whcih file that error is and after that u need to check which block
--> Beacuse we have multiple resource block 

------------------------------
cat main.tf
provider "aws" {
}

resource "aws_instance" "one" {
count = var.instance_count
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}
------------
cat variables.tf
variable "instance_type" {
}

variable "instance_count" {
}
------------
cat raham.tfvars
instance_type = "t2.medium"
instance_count = 3
------------
cat dev.tfvars
instance_type = "t2.medium"
instance_count = 3
------------
cat test.tfvars
instance_type = "t2.micro"
instance_count = 5

FOR DEV ENV: terraform apply --auto-approve -var-file="dev.tfvars"
FOR TEST ENV: terraform apply --auto-approve -var-file="test.tfvars"

------------------------------
TERRAFORMCLI: used to pass values from cli

provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-0fa7190e664488b99"
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}

variable "instance_type" {
}

terraform apply --auto-approve -var="instance_type=t2.medium"
terraform destroy --auto-approve -var="instance_type=t2.medium"
------------------------------
provider "aws" {
}

resource "aws_instance" "one" {
ami = var.ami_id
instance_type = var.instance_type
tags = {
Name = "terra-server"
}
}

variable "instance_type" {
}

variable "ami_id" {
}

terraform apply --auto-approve -var="instance_type=t2.large" -var="ami_id=ami-0fa7190e664488b99"
terraform destroy --auto-approve -var="instance_type=t2.large" -var="ami_id=ami-0fa7190e664488b99"

------------------------------
TERRAFORM OUTPUTS: used to print the resource properties.
ex: public-ip, dns, instance type


provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-0fa7190e664488b99"
instance_type = "t2.micro"
tags = {
Name = "terra-server"
}
}

output "raham" {
value = [aws_instance.one.public_ip, aws_instance.one.private_ip, aws_instance.one.public_dns]
}

terraform apply --auto-approve
terraform destroy --auto-approve

---------------------------------------------------------------------------------------------------------------------------------------------
Lec - 47
---------------------------------------------------------------------------------------------------------------------------------------------
## AWS Terraform Instnaces

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

terraform apply --auto-approve
------------------------------
vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

terraform apply --auto-approve

------------------------------
## Terraform taint

Terraform taint = used to recreate specific objects 
in real time some resource we need to recreate if it will not work properly
then we can use taint concpet.
- here no need to execute the entire file.
- we can just mark the object as tainted.

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
}

terraform apply --auto-approve
terraform state list

for example , in  above tf file the aws_instance resource block with label name is not working i want to recreate , so in that case terraform taint is used.
-->
terraform taint aws_instance.four
terraform apply --auto-approve
--> so it will recreate the object(i.e resource aws_instance block)

------------------------------
## Terraform LifeCycle

Prevent_destroy : used to keep secure our resources without destrying

vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
}

resource "aws_iam_user" "three"{
name = "karank"
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
lifecycle {
prevent_destroy = true    # means it is not going to destroy 
}
}

terraform apply --auto-approve
terraform state list

------------------------------
vim main.tf

provider "aws"{
regiom = "us-east-1"
}

resource "aws_s3_bucket" "one"{
bucket = "prasadk0143terrbucket"
lifecycle {
prevent_destroy = false
}
}

resource "aws_ebs_volume" "two"{
sice = 10
availability_zone = "us-east-1b"
tags = {
Name = "prasad-ebs"
}
lifecycle {
prevent_destroy = false
}
}

resource "aws_iam_user" "three"{
name = "karank"
lifecycle {
prevent_destroy = false
}
}

resource "aws_instance" "four"{
ami = "ami-0fa7190e664488b99"
instance_type "t3.micro"
tags = {
Name = "prasad-terrserver"
}
lifecycle {
prevent_destroy = true    # means it is not going to destroy 
}
}

terraform apply --auto-approve
terraform state list
->> means all resource are not getiing to destroy if i give prevent_destroy = false for particular block

---------------------------------------------------------------------------------------------------------------------------------------------
Lec - 48
---------------------------------------------------------------------------------------------------------------------------------------------
You should know about which software is on whcih server (like APP application is on APP server)
in short u should about 3-tier architecture if dont know then u cant work in real time.

          To see Applcication           To Use Application          To store & retrive data
          --------------------          -------------------          ----------------------   
          |    WEB Server    |          |     APP Server  |          |    DB Server       |
          |                  |          |                 |          |                    | 
          | e.g Apache,Nginx |          | e.g TOMCAT,JAVA |          | e.g MYSQL,ORACLE   |
          |  port no. 80     |          | PYTHON,NODE-JS  |          | ARANGODB,POSTGRESQL|
          |                  |          |                 |          |                    |
          |                  |          |                 |          |                    |
          --------------------          -------------------          ----------------------   

purge = to uninstall packages on ubuntu
e.g. apt purge apache2 -y

* there is no need to install git explicitly,it is going install to defaultly*
when it comes to ubuntu it might be apache or nginx there is no need to start the service, by default is starting phase
------------------------------------------------------------
TO run any Software:
PYTHON:
- Python is a high level, dynamic and general purpose programing language.
- It was designed and developed by Python Software Foundation.

COMMANDS :
sudo apt-get update -y
sudo apt-get upgrade -y
sudo apt-get install python3 -y
sudo apt-get install python3.8 -y
apt install python3-pip -y
pip install Numpy
pip install Pandas

python3: THis will take you to space where you can write the python code.
TO exit from that workspace give exit() 
------------------------------------------------------------
To run DB Server:
ARANGO-db :

vim arango.sh 
sh arango.sh 

echo 'deb https://download.arangodb.com/arangodb34/DEBIAN/ /' | sudo tee /etc/apt/sources.list.d/arangodb.list
wget -q https://download.arangodb.com/arangodb34/DEBIAN/Release.key -O- | sudo apt-key add -
sudo apt update -y
sudo apt -y install apt-transport-https
sudo apt -y install arangodb3
sudo systemctl start arangodb3
sudo systemctl status arangodb3
sudo arangosh

db._createDatabase("db1");      -> To create database in arangodb
db._showDatabases();            -> To show datbases

To see ArangoDb on GUI :
--> for that we need to modify configuration file.
vim /etc/arangodb3/arangod.conf  -> in Endpoint = coment out first endpoint and instead(0.0.0.0) this paste your server private ip address  -> systemctl restart arangodb3.service -> and the public IP address paste on your browser

------------------------------------------------------------
MYSQL :

vim mysql.sh
sh mysql.sh

wget https://repo.percona.com/apt/percona-release_latest.$(lsb_release -sc)_all.deb
sudo dpkg -i percona-release_latest.$(lsb_release -sc)_all.deb
percona-release setup ps80
sudo apt install percona-server-server -y
mysql -u root -p

CREATE DATABASE PRASAD;      -> To create Database
SHOW DATABASES;              -> TO show databases
USE PRASAD;                  -> TO use that particular database
DROP DATABASE PRASAD;        -> To delete database 

------------------------------------------------------------
JFrog: Artifactory Service 
--> Whenever the application got fail, if u store the war file separately we can able to rollback.

maven --> .war --> .jar
war file = artifactory


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Lec - 49
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Terraform Locals : 
- its a block used to define a values.
- we can define the value once and used it for multiple time.

Q. What is Workspace in Teraform ?

vim main.tf          = for dev area

provider "aws" {
region = "ap-south-1"
}

locals {
env = "dev"
}

resource "aws_vpc" "one" {
cidr_block = "10.0.0.0/16"
tags ={
Name = "${local.env}-vpc"
}
}

resource "aws_subnet" "two" {
cidr_block = "10.0.0.0/16"
availability_zone = "ap-south-1a"
vpc_id = aws_vpc.one.id
tags = {
Name = "${local.env}-subnet"
}
}

resource "aws_instance" "three" {
subnet_id = aws_subnet.two.id
ami = "ami-0fa7190e664488b99"
instance_type = "t3.micro"
tags = {
Name = dev-server
]
}

terraform init
terraform validate      = it is used for if there is an spelling mistake or not if yes then it will suggest
terraform plan
terraform apply --auto-approve

-------------------------------------
If I create the below test area with tf then the dev area will be remove automatically. so for that we have concept is Workspace.
-------------------------------------

vim main.tf          = for testing area

provider "aws" {
region = "ap-south-1"
}

locals {
env = "dev"
}

resource "aws_vpc" "one" {
cidr_block = "10.0.0.0/16"
tags ={
Name = "${local.env}-vpc"
}
}

resource "aws_subnet" "two" {
cidr_block = "10.0.0.0/16"
availability_zone = "ap-south-1a"
vpc_id = aws_vpc.one.id
tags = {
Name = "${local.env}-subnet"
}
}

resource "aws_instance" "three" {
subnet_id = aws_subnet.two.id
ami = "ami-0fa7190e664488b99"
instance_type = "t3.micro"
tags = {
Name = dev-server
]
}

terraform init
terraform validate    
terraform plan
terraform apply --auto-approve
-------------------------------------------------

TERRAFORM WORKSPACES:
- workspace is used to isloate the envs.
- In real time we create infra for envs by using workspace only.
- by default we have a default workspace.
- if we perform an operation on one workspace it wont affect another workspace

COMMANDS :
terraform workspace list           : to list down all workspaces
terraform workspace new dev        : to create new workspace
terraform workspace show           : to show current workspace
terraform workspace select test    : to switch the workspace
terraform workspace delete test    : to delete the workspace

NOTE:
1. we can't delete our current workspace.
2. we can't delete our workspace without deleting resources.
3. we cant't delete default workspace.

------------------------------------
terraform workspace new dev
vim main.tf

provider "aws" {
region = "ap-south-1"
}

locals {
env = "${terraform.workspace}"
}

resource "aws_vpc" "one" {
cidr_block = "10.0.0.0/16"
tags ={
Name = "${local.env}-vpc"
}
}

resource "aws_subnet" "two" {
cidr_block = "10.0.0.0/16"
availability_zone = "ap-south-1a"
vpc_id = aws_vpc.one.id
tags = {
Name = "${local.env}-subnet"
}
}

resource "aws_instance" "three" {
subnet_id = aws_subnet.two.id
ami = "ami-0fa7190e664488b99"
instance_type = "t3.micro"
tags = {
Name = dev-server
]
}

terraform apply --auto-approve
------------------------------------------

terraform workspace new test
vim main.tf

provider "aws" {
region = "ap-south-1"
}

locals {
env = "${terraform.workspace}"
}

resource "aws_vpc" "one" {
cidr_block = "10.0.0.0/16"
tags ={
Name = "${local.env}-vpc"
}
}

resource "aws_subnet" "two" {
cidr_block = "10.0.0.0/16"
availability_zone = "ap-south-1a"
vpc_id = aws_vpc.one.id
tags = {
Name = "${local.env}-subnet"
}
}

resource "aws_instance" "three" {
subnet_id = aws_subnet.two.id
ami = "ami-0fa7190e664488b99"
instance_type = "t3.micro"
tags = {
Name = dev-server
]
}

terraform apply --auto-approve
terraform destroy --auto-approve
terraform workspace delete test
-----------------------------------------------------

TERRAFORM GRAPH: used to show the flow chart of our infrastructure 
terraform graph
copy paste the content in graphviz wesbite online


-----------------------------------------------------
ALIAS AND PROVIDER: used to create resources on mutliple regions in single file.

provider "aws" {
region = "us-east-1"
}

resource "aws_instance" "one" {
ami = "ami-00c6177f250e07ec1"
instance_type = "t2.micro"
tags = {
Name = "nvirgina-server"
}
}

provider "aws" {
region = "ap-south-1"
alias = "mumbai"
}

resource "aws_instance" "two" {
provider = aws.mumbai
ami = "ami-03d294e37a4820c21"
instance_type = "t2.micro"
tags = {
Name = "mumbai-server"
}
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Lec - 50
---------------------------------------------------------------------------------------------------------------------------------------------------------------
LIFECYCYLE:

1. PREVENET_DESTROY: it wont destroy the resource even if we run destroy command
2. IGNORE CHANGES: it will not replicate the changes we have done to server (i.e it ignore the changes done on server)
3. DEPENDS ON: it will depend on other resource to create (e.g if s3 bucket is created then only ec2 instnace will create)

1. Prevent_Destroy :

vim main.tf 

provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-01eccbf80522b562b"
instance_type = "t2.large"
tags = {
Name = "abc-server"
}
lifecycle {
prevent_destroy = true
}
}

provider "aws" {
}

resource "aws_instance" "one" {
ami = "ami-01eccbf80522b562b"
instance_type = "t2.large"
tags = {
Name = "abc-server"
}
lifecycle {
prevent_destroy = true
}
}

-----------------------------------------------------
TERRAFORM REMOTE BACKEND SETUP:
when we create infra the information of resources will store on state file.
so it will be tracking the infra information.
so we need to take backup of that file.
if we lost that file we cant track the infra.
so we prefer to locate the state file on remote loaction.
here im using s3 as remote backend.

create a bucket manually

provider "aws" {
region = "us-east-1"
}

terraform {
  backend "s3" {
    bucket = "swiggypordinfrabuckt0099"
    key    = "swiggy/terraform.tfstate"
    region = "us-east-1"
  }
}

resource "aws_instance" "one" {
ami = "ami-00c6177f250e07ec1"
instance_type = "t2.micro"
tags = {
Name = "nvirgina-server"
}
}

Note: while using new provider block always we need to run terraform init
otherwise plugins will not be downloaded

COMMAND :
terraform refresh          : to refresh all the things in the state file
- used to refresh and replicate the changes to state file. 
- it will comapre terrform state file with resources.
- if it is exist it will show, otherwise it will not show
e.g. if I remove the ec2 instnace manually so then i check in state file(.tfstate) it will present there beacuse it not yet refresh. after i firing refresh command it remove that instance from state file also.
in short it will check that if resource is there or not 

-----------------------------------------------------
To create LOCAL RESOURCES :
- if you want to create local resources then you have to install plugin of that resource
- how i can do this -> justwith the help of terraform init command -> it will download all related plugins to create that resource

provider "aws" {
}

resource "local_file" "one" {
filename = "abc.txt"
content = "hai all my name is terraform"
}
-----------------------------------------------------
TERRAFORM VERSION CONSTRATINTS:
- it is used to change the provider version plugins.
- can b applicable for all providers.

without updating the provider plugins we cant create new resources

provider "aws" {
}

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.17.0"
    }
  }
}

"> 5.17.0, < 5.19.0" & ">5.17.0" & "<5.19.0"

terraform {
  required_providers {
    local = {
      source = "hashicorp/local"
      version = "2.2.2"
    }
  }
}

-----------------------------------------------------
DYNAMIC BLOCK: it is used to reduce the length of code and used for reusabilty of code in loop.
egress = means outbound rules --> just like we give all things while creating ec2 instance (e.g.security group,port numbers,all traffic)

Q. WHat is Dynammic BLock in Terraform ?
-> to reduce the length of code 
-> for example -> security group, for each and every group we need to write multiple lines of code, but ports i will define on ingress and i can call the values on dynamic block, autmaitcaly reduce the line of code
work of for_each = it is going to pick the values from ingress rules , it is going to pick each and every values one by one 

provider "aws" {
}

locals {
  ingress_rules = [{
    port        = 443
    description = "Ingress rules for port 443"
    },
    {
      port        = 80
      description = "Ingree rules for port 80"
  },
  {
      port        = 8080
      description = "Ingree rules for port 8080"

  }]
}

resource "aws_instance" "ec2_example" {
  ami                    = "ami-0c02fb55956c7d316"
  instance_type          = "t2.micro"
  vpc_security_group_ids = [aws_security_group.main.id]
  tags = {
    Name = "Terraform EC2"
  }
}

resource "aws_security_group" "main" {

  egress = [
    {
      cidr_blocks      = ["0.0.0.0/0"]
      description      = "*"
      from_port        = 0
      ipv6_cidr_blocks = []
      prefix_list_ids  = []
      protocol         = "-1"
      security_groups  = []
      self             = false
      to_port          = 0
  }]

  dynamic "ingress" {
    for_each = local.ingress_rules

    content {
      description = "*"
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }

  tags = {
    Name = "terra sg"
  }
}

-----------------------------------------------------
TERRAFORM FRT: to set the allignment for my code

FOR_EACH:

provider "aws" {
}

resource "aws_instance" "two" {
for_each = toset(["web-server", "app-server", "db-server"])
ami = "ami-04beabd6a4fb6ab6f"
instance_type = "t2.micro"
tags = {
Name = "${each.key}"
}
}

AWS - CFT
AZURE - ARM
GCP - GDE

-----------------------------------------------------
Another mehtod to crete multiple instances with minimal code

provider "aws" {
}

resource "aws_instance" "two" {
count = length(var.instance_type)
ami = "ami-04beabd6a4fb6ab6f"
instance_type = var.instance_type[count.index]
tags = {
Name = vavr.instance_name[count.index
}
}

variable "instance_type"{
default = ["t2.medium","t2.micro","t2.nano"]
}

variable "instance_name"{
default = ["webserver","appserver","dbserver"]
}

-----------------------------------------------------
Q. What is Deployement ?
-> The term Deplyements refers the installation of Web_applcaition on Web Application Server.

WEB APPLICATION : webservers (TOmcat,Nginx,Jboss,ISS)
- A web application is a program that can be accessed via browser and is linked to database
- can interact with en users
- we can Read and Manipulate
- Compex Functionality 

Website v/s Web-Application
- If u have only frontend code then that is Website(APACHE server)
- but if u have frontend + backend code then it will web-applacition(TOMCAT)

WEBSITE : webserver: (HTTPD,NGINX)
- A website is a coolectio nof relate pages conatinign images,audo,or videos linked by a single domain name.
- can't ineract with end users
- we can't Read and Manipulate
- Simple Functionality 

WHY WE NEED ?
The Main essence of the DEplyemnets is :
- Adding New Features to the Application
- Removing the bugs
- Enhancing the New Features
- Improving the Performance
- Breaking Large Applcaiton to Microsrvices

THINGS NEED FOR THE DEPLOYEMENTS :
- We need to have Infra Setup
- New Release of code  
- Involvement of Dev, QA, and Devops Team
- Creating New DB's if needed
- APproval from RM (in case of New release)
 
THINGS TO CONSIDER AND TAKEN CARE WHILE DEPLOYMENT.
- Need to take Backups of the Current Builds and DataBases.
- Need To Provide Isolated Environments for Dev, Test and Prod.
- Can be able to do RollBack if the Deployment fails in some cases.
- Make sure we are deploying the correct env and Client Application Servers.
